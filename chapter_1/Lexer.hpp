#ifndef LEXER_H
#define LEXER_H
#include <vector>
#include <string>
#include <unordered_set>
#include<iostream>
#include<stdexcept>

#include "Token.hpp"
/*
    This class iterates over the character In the source file, and construct Tokens for the different symbols.
    Ignores whitespaces. Tokens are defined in Token.hpp

    symbol: A string within the source code
*/
class Lexer{
    std::vector<Token> tokens;
    std::unordered_set<std::string> keywords={"int","return","void"};
    private:
        /*
            Checks if the current character is a whitespace
            @param c the character to check
            @return A bool, True if the character is a \t,\n,\r,' ' false if not
        */
        bool isWhiteSpace(char& c);
        
        /*
            Checks if the current character is a letter
            @param c the character to check
            @return A bool, True if the character is a letter a-z or A-Z including '_' false if not
        */
        bool isLetter(char& c);
        /*
            Checks if the current characters is a digit.
            @param c the character to check
            @return A bool, True if the character is a digit 0-9 false if not
        */
        bool isDigit(char& c);
    
        /*
            If the character isn't a single character symbol (i.e "{","}"."(",")",";" ), and is a letter or character,
            traverse the following characters and construct a symbol. This can either be a string representing a number
            i.e "12344", or a string representing an identifier i.e "main"
            @param it An iterator to the current character in the file
            @param end An iterator pointing to the space after the end of the string representing the file.
            @param type The expected Token type based on the first character in the symbol. If the first character is a digit, the expected type is CONSTANT, else 
            is IDENTIFIER
            
        */
        std::string createSymbol(std::string::iterator& it, std::string::iterator end,TokenType type);
        /*
            Checks if the symbol generated is a Keyword i.e int, void
            @param symbol std::string representing the symbol to check
            @return a bool
        */
        bool isKeyword(std::string symbol);

        /*
        *@brief  at the token pos indices away from it
            @param it iterator of the current position
            @param pos The number of positions away you want to look at
            @return An iterator pos away from the current iterator.
        */
        std::string::iterator lexerPeek(std::string::iterator& it,int pos);
    public:
        /**
         * @brief Converte a string into a file, Intended to be used after opening the source file and converting the file into a string object.
         * 
         * @param str 
         */
        void tokenize(std::string str);
        /**
         * @brief Prints the tokens generted by the Lexer to console
         * 
         */
        void printTokens();
        /**
         * @brief Get the Tokens vector, which holds the Tokens generated by the Lexer.
         * 
         * @return std::vector<Token> 
         */
        std::vector<Token> getTokens();

    };
#endif